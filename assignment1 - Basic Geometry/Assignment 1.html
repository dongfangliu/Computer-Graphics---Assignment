
<!-- saved from url=(0131)http://sist.shanghaitech.edu.cn/faculty/liuxp/course/s!AvhyQ31jLRnowxhOB64TPHRdbjic3gh2cg1/assignments/assignment1/assignment1.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=GBK">
<style type="text/css">
.math{
	font-style: italic;
}
.equation{
	display: block;
}
</style>

<title>Assignment 1</title>

</head><body><p align="center"><font face="Trebuchet MS" size="6"><b>Assignment 1</b> 
- Creating your first OpenGL program<br>
　</font></p>
<hr style="background-color: #666666" color="#666666" size="1">
<p align="left"><b><font face="Trebuchet MS" size="4">Introduction</font></b></p>
<p align="left"><font face="Trebuchet MS">In this assignment, you are required 
to create your first graphics program using <a href="https://www.opengl.org/">
OpenGL</a>. As you have learned in the course as well as the tutorials, to start 
up your first graphics program, you will need to use
<a href="http://www.glfw.org/">GLFW</a> to create a window. By default, GLFW 
will create a window with double buffering enabled. Then, you can use the basic 
OpenGL calls to draw 3D objects on the window, shade the object with the 
built-in Phong lighting model, transform the 3D objects, as well as manipulate 
the cameras to navigate through the virtual scene. To prevent aliasing 
artifacts, you can also enable antialiasing in GLFW window as well as OpenGL. In the following, we will give you the specifics about what you need to 
accomplish, as well as some related guidelines in order to assist your 
programming.</font></p>
<hr style="background-color: #666666" color="#666666" size="1">
<p align="left"><b><font face="Trebuchet MS" size="4">Things to be done</font></b></p>
<p align="left"><font face="Trebuchet MS" size="3">- <b>[must]</b> A basic 
window-based program for OpenGL rendering, where multi-sample full-screen 
antialiasing is enabled.<br>
- <b>[must]</b> The basic rendering program, where you are required to draw 
simple objects </font><font face="Trebuchet MS">such as tetrahedron, cubes and 
spheres, and then shade them with </font><font face="Trebuchet MS">Phong 
lighting.</font><font face="Trebuchet MS" size="3"><br>
- <b>[must]</b> Manipulate the objects by translating and rotating them, and 
manipulate the cameras by constructing the new camera matrix with gluLookAt(...) 
and use keyboard to control the camera: you can use keyboard to translate and 
rotate the camera so that you can walk in the virtual scene.<br>
- <b>[optional] </b>You can build a shader program to support Phong shading or 
you can support lighting with multiple point light sources, etc.</font></p>

<hr style="background-color: #666666" color="#666666" size="1">
<p align="left"><b><font face="Trebuchet MS" size="4">Submission &amp; demonstration</font></b></p>
<p align="left"><font face="Trebuchet MS" size="3">Code submission deadline:
<font color="#FF0000">2018-3-2</font></font><font face="Trebuchet MS" color="#FF0000">3, 
23:59pm<br>
</font><font face="Trebuchet MS">Demonstration date &amp; time: </font>
<font color="#FF0000" face="Trebuchet MS" size="3">2018-3-2</font><font face="Trebuchet MS" color="#FF0000">6, 
7pm</font><font face="Trebuchet MS" size="3"><font color="#FF0000">-9pm<br>
</font>Please send your code package and technical report to TAs though email (<font color="#0000FF"><u>check 
who you should send your assignment to on Piazza</u></font>)</font></p>
<hr style="background-color: #666666" color="#666666" size="1">
<p align="left"><b><font face="Trebuchet MS" size="4">Grading rules</font></b></p>
<p align="left"><font face="Trebuchet MS" size="3">- The [must] items are things 
that you must finish. When you have finished all the [must] items and 
demonstrate them successfully in front of TAs, you will get all the scores for 
the programming part. [90%]<br>
- In addition to programming, you will also need to submit a technical report 
specifying the details of your implementation: what you have done and how you 
achieve them. [10%]<br>
- You can also choose to do optional items, and if you choose to do it, you will 
get additional scores based on the additional work you have done. But the 
maximum additional score will not exceed 20% of the entire score of this 
assignment. <br>
- Late submission of your assignment will subject to score deduction. Please refer to
</font><font face="Trebuchet MS"><u><a href="http://sist.shanghaitech.edu.cn/faculty/liuxp/course/s!AvhyQ31jLRnowxhOB64TPHRdbjic3gh2cg1/assignments/index.html">Late hand-in policy</a></u> 
for details.</font></p>
<hr style="background-color: #666666" color="#666666" size="1">
<p align="left"><b><font face="Trebuchet MS" size="4">Note:<br>
Before doing the assignment, please read the materials on OpenGL programming at
<a href="http://www.opengl-tutorial.org/beginners-tutorials/">site1</a>,
<a href="http://www.songho.ca/opengl/index.html">site2</a>. You can also read
<a href="https://learnopengl.com/">site3</a> which conducts OpenGL rendering 
based on OpenGL Mathematics (<a href="https://glm.g-truc.net/0.9.8/index.html">GLM</a>) 
library.</font></b></p>
<hr style="background-color: #666666" color="#666666" size="1">
<p align="left"><b><font face="Trebuchet MS" size="4">Step 1: Compiling and 
building your dependencies</font></b></p>
<p align="left"><font face="Trebuchet MS" size="3">In this assignment, you are 
required to finish a small programming project based on OpenGL. Before you 
really start programming your own code, you need to first setup your 
environment. You need two things in order to get started:
<a href="http://glew.sourceforge.net/">GLEW</a> and
<a href="http://www.glfw.org/">GLFW</a>. GLEW is the OpenGL extension wrangler 
library that contains all the OpenGL API functions based on which you can call 
to make OpenGL draws, whereas GLFW is a multi-platform library for creating 
windows on which your 3D objects are drawn. There are specific guidelines for
<a href="http://glew.sourceforge.net/build.html">building up GLEW</a> or
<a href="http://www.glfw.org/docs/latest/compile_guide.html">compiling and 
installing GLFW</a>, on all platforms, and you can read and follow the steps. To 
link these dependencies into your program, you only need to link the related 
static library (*.lib for windows, and *.a for Linux) for these dependencies, 
and put the associated dynamic linked library (*.dll for windows and *.so for 
Linux) in the executable folder for running the program.</font></p>
<p align="left"><b><font face="Trebuchet MS" size="4">Step 2: Creating the window 
program using GLFW</font></b></p>
<p align="left"><font face="Trebuchet MS">Once you have set up your environment, 
you can start creating your first window program using GLFW. You can take a 
reference from <a href="http://www.glfw.org/docs/latest/quick.html">here</a> 
which illustrates the step-by-step process for window creation. Here, we only 
give a brief introduction based on the following basic code:<br>
<br>
int main()<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glfwInit();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GLFWwindow* window = 
glfwCreateWindow(SCREEN_WIDTH, SCREEN_HEIGHT, "LearnOpenGL", NULL, NULL);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (window == NULL)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; 
"Failed to create GLFW window" &lt;&lt; std::endl;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glfwTerminate();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glfwMakeContextCurrent(window);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glfwSetFramebufferSizeCallback(window, 
framebuffer_size_callback);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glewInit();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glEnable(GL_DEPTH_TEST);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //register callback function<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //initPMV();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (!glfwWindowShouldClose(window))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
glClearColor(0.2f, 0.3f, 0.3f, 1.0f);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //...draw() 
function<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
glfwSwapBuffers(window);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
glfwPollEvents();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</font></p><p align="left">
<font face="Trebuchet MS">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glfwTerminate();<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<br>
}</font></p><p align="left"><font face="Trebuchet MS" size="3">Here, the function glfwInit() initializes the GLFW library 
before any GLFW functions can be used,  
and before the application exits, GLFW 
should be terminated in order to free any resources allocated glfwTerminate(). 
To create a window, we use glfwCreateWindow(), and such a window can be associated 
with the OpenGL rendering context by calling glfwMakeContextCurrent(), which 
takes the window pointer as its argument. We also need to register a framebuffer 
size call-back function using glfwSetFramebufferSizeCallback() such that when 
the size of the specified window is changed, it will be called to reset the 
projection. The 
function glClearColor() set current window's background color. The glClear() is used to clear 
both color and depth buffer to its default value. The glfwSwapBuffers()
can swap the front and back buffers of the specified window and the glfwPollEvents() monitors user inputs. 
To make correct depth order, you can enable depth test in OpenGL by




</font><font face="Trebuchet MS">glEnable(GL_DEPTH_TEST). </font>
<font face="Trebuchet MS" size="3">You can also enable multi-sample antialiasing with a call to glfwWindowHint and assign GLFW_SAMPLES 
with the number of samples you want, and then enable antialiasing in OpenGL with 
glEnable(...). Search for "OpenGL multi-sampling" for more information online.<br>



</font></p><p><font face="Trebuchet MS" size="3"> The function initPMV() is a user-defined function which you need to write  to set 
model-view and projection matrix. It may look like this:
</font></p><div align="left"><font face="Trebuchet MS" size="3">
<p align="left"><code>
<br>
</code>void initPMV()<br>
{<br>
<font face="Trebuchet MS">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font>glMatrixMode(GL_PROJECTION);<br>
<font face="Trebuchet MS">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font>glLoadIdentity();	
<br>
<font face="Trebuchet MS">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font>gluPerspective(60, SCREEN_WIDTH / SCREEN_HEIGHT, 0.1, 100);<br>
	<br>
<font face="Trebuchet MS">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font>glMatrixMode(GL_MODELVIEW);<br>
<font face="Trebuchet MS">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font>glLoadIdentity();<br>
<font face="Trebuchet MS">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font>gluLookAt<br>
<font face="Trebuchet MS">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font>(<br>
<font face="Trebuchet MS">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</font>3, 3, 3,<br>
<font face="Trebuchet MS">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</font>0, 0, 0,<br>
<font face="Trebuchet MS">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</font>0, 1, 0<br>
<font face="Trebuchet MS">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font>);<br>
}<code><br>
</code></p></font></div><font face="Trebuchet MS" size="3">
glMatrixMode() sets current matrix model. glLoadIdentity() sets current matrix as 
	identity matrix. gluPerspective() sets up a 
perspective projection matrix. gluLookAt() defines a viewing transformation. When you create a window successfully, you can write 
	your own draw() function 
to generate and manipulate your 3D objects. 
<p></p>




</font> <p></p>
<p align="left"><b><font face="Trebuchet MS" size="4">Step 3: Create meshes 
(tessellation) of 3D objects</font></b></p>

<p align="left"><font face="Trebuchet MS" size="3">
Now you can draw some 3D objects by calculating and specifying vertex coordinates of the 
geometries. For example, you can easily draw a triangle like this:
</font></p>

	<p>
<font face="Trebuchet MS" size="3">void drawTriangle()<br>
{<br>
<font face="Trebuchet MS">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font>glBegin(GL_TRIANGLES);<br>
<font face="Trebuchet MS">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font>glColor3f(0.6, 0.2, 0.3);<br>
<font face="Trebuchet MS">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font>glVertex3f(0, 0, 1);<br>
<font face="Trebuchet MS">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font>glVertex3f(1, 0, 0);<br>
<font face="Trebuchet MS">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font>glVertex3f(0, 1, 0);<br>
<font face="Trebuchet MS">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font>glEnd();<br>
}</font></p>
<p><font face="Trebuchet MS" size="3">The glBegin() and glEnd() functions delimit the vertices of a primitive or a group of primitives.
The glBegin in pseudo code which uses GL_TRIANGLES parameter represents that  vertices between glBegin() and glEnd() will 
in triangle order. glColor3f performs the clear operation on one or more buffers at the same time. glVertex3f() specifies a vertex 
in 3D. </font>
</p>
<p><font face="Trebuchet MS" size="3">Adding the drawTriangle() in the draw() 
function of the previous program, you can get a drawn triangle in your window like 
this:</font></p>
	<p align="center"><font face="Trebuchet MS" size="3">
<img src="./Assignment 1_files/triangle.png" class="clean" alt="phong components" width="400" align="left">
	</font></p>


<p align="left">　</p>
	<p align="left">　</p>
	<p align="left">　</p>
	<p align="left">　</p>
	<p align="left">　</p>
	<p align="left">　</p>
	<p align="left">　</p>
	<p align="left">　</p>
	<p align="left">　</p>
	<p align="left">　</p>
	<p align="left"><font face="Trebuchet MS">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	Figure</font><font face="Trebuchet MS" size="3"> 1: A single 3D triangle</font></p>
	<font face="Trebuchet MS" size="3">
<p>To draw a tetrahedron, you only need to draw four triangles since each face in a tetrahedron is a triangle, so you can directly set the 
vertex coordinates of the four triangles like: </p><p>
glBegin(GL_TRIANGLES);<br>
<br>
&nbsp;&nbsp;&nbsp; //draw triangle 1<br>
&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp; //draw triangle 2</p>
	<p>
&nbsp;&nbsp;&nbsp; //draw triangle 3</p>
	<p>
&nbsp;&nbsp;&nbsp; //draw triangle 4<br>
<br>
glEnd();<br>
	</p>
<p></p>
</font><p></p>
	<p align="left"><font face="Trebuchet MS" size="3">To draw the cube, we can 
	directly draw four rectangles. In fact, OpenGL provides the method which can draw a rectangle 
	directly. 
You can set glBegin() function's parameter GL_QUADS like:
	</font></p><div align="left"><font face="Trebuchet MS" size="3">
		<p align="left">
glBegin(GL_QUADS);<br>
<font face="Trebuchet MS">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font>glNormal3f(0.0f, 0.0f, 1.0f);<br>
<font face="Trebuchet MS">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font>glVertex3f(0.5f, 0.5f, 0.5f);<br>
<font face="Trebuchet MS">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font>glVertex3f(-0.5f, 0.5f, 0.5f);<br>
<font face="Trebuchet MS">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font>glVertex3f(-0.5f, -0.5f, 0.5f);<br>
<font face="Trebuchet MS">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font>glVertex3f(0.5f, -0.5f, 0.5f);&nbsp;
<br>
glEnd();<br>
<br>
		</p></font></div><font face="Trebuchet MS" size="3">
When you draw four rectangle in any order, you will get your cube. </font>
<p align="left"><font face="Trebuchet MS">Draw a sphere is more complicated, and 
t</font><font face="Trebuchet MS" size="3">here can be many methods to generate 3D sphere point. This <a href="https://stackoverflow.com/questions/7687148/drawing-sphere-in-opengl-without-using-glusphere">DrawSphere</a>
will help you, but you should not use gluSphere which is a built-in utility 
function for OpenGL. The simplest method to draw a sphere is to use spherical 
coordinates, and a sphere can be expressed by the following parametric equation:</font></p><p><font face="Trebuchet MS" size="3">F(u, v) = [ cos(u)*sin(v)*r, cos(v)*r, sin(u)*sin(v)*r ],</font></p><font face="Trebuchet MS" size="3">

<p>where:</p>
<ul>
<li>r is the sphere radius;</li>
<li>u is the longitude, ranging from 0 to 2π; and</li>
<li>v is the latitude, ranging from 0 to π.</li>
</ul>
You can set a r and generate 3D point by traverse u from 0 to 2π and v from 0 to 
		π, using a fixed step size you set, e.g., the step size can be set to 
		π/10, but you can make this step size even smaller to get more accurate 
		sphere.
After generating data, you need know the connected relation between points. You can use triangles or quads to link these points and draw them using 
		OpenGL. Try to think about how to create such connectivity and draw the 
		sphere. <br>
		<br>
		Check more for drawing geometric object in OpenGL at
		<a href="http://www.songho.ca/opengl/gl_vertexarray.html">site1</a> &amp;
		<a href="https://learnopengl.com/Getting-started/Hello-Triangle">site2</a>.</font><p align="left">
		<b><font face="Trebuchet MS" size="4">Step 4: Rendering 3D objects with 
		Phong lighting model</font></b></p>

		<font face="Trebuchet MS" size="3">Up to now, you will find that objects you 
		have drawn won't appear to be 3D once it is filled with a color. The 
		reason is that you do not have a lighting model applied to give the 
		appropriate shading on its appearance. In physical world, when you look at an 
		object's surface, your eye's perception of the color depends on the 
		energy distributions of photons that arrive and trigger your visual cone cells.  Those photons come from a light source or 
		a combination of light sources, some of which 
 are absorbed and the other are reflected by the surface. In addition, different surfaces may have very different 
		reflection properties - some 
 are shiny and preferentially reflect light in certain directions, while others scatter incoming light equally in all directions. 
 Most surfaces are somewhere in between these two extreme cases. </font>
 <p><font face="Trebuchet MS" size="3">In OpenGL, the lighting phenomena is approximated as if 
	the light can be decomposed into red, green, and blue components. Thus, 
 the color of the light sources is characterized by the amount of red, green, and blue light they emit, 
 and the material property of surfaces is characterized by the percentage of the incoming red, green, and blue components that is reflected in various directions.
	<br>
	<br>
	<b>Phong lighting model. </b>The OpenGL lighting model considers the lighting to be divided into 
	three independent components: ambient, 
diffuse, and specular. All these components are computed independently and then added together.

<br>

		</font></p><font face="Trebuchet MS" size="3">

<p>
OpenGL provides glLightfv() to set ambient, diffuse and specular component of the light, 
e.g.,:
		</p><div align="left">
			<p align="left">
GLfloat sun_light_position[] = { 0.0f, 6.0f, 0.0f, 0.0f }; <br>
GLfloat sun_light_ambient[] = { 0.0f, 0.0f, 0.0f, 1.0f }; <br>
GLfloat sun_light_diffuse[] = { 1.0f, 1.0f, 1.0f, 1.0f }; <br>
GLfloat sun_light_specular[] = { 1.0f, 1.0f, 0.0f, 1.0f };&nbsp; <br>
glLightfv(GL_LIGHT0, GL_POSITION, sun_light_position);<br>
glLightfv(GL_LIGHT0, GL_AMBIENT, sun_light_ambient);<br>
glLightfv(GL_LIGHT0, GL_DIFFUSE, sun_light_diffuse);<br>
glLightfv(GL_LIGHT0, GL_SPECULAR, sun_light_specular);<br>
<br>
			</p></div>
<p></p>
			After you define the characteristics of the light sources you want, you have to turn them on with the glEnable() command. You also need to call glEnable() 
with GL_LIGHTING as a parameter to prepare OpenGL to perform lighting calculations. 

With OpenGL, you need to explicitly enable (or disable) lighting. If lighting isn't enabled, the current color is simply mapped onto the current vertex, 
and no calculations concerning normals, light sources, the lighting model, and material properties are performed. Here's how to enable lighting:
			<div align="left">
				<p align="left">glEnable(GL_LIGHTING);</p></div>
<p>To disable lighting, call glDisable() with GL_LIGHTING as the argument. You also need to explicitly enable each light source that you define, after you've specified the parameters for that source.</p>
				<div align="left">
					<p align="left">glEnable(GL_LIGHT0); </p></div>
<p>After you enable the light, you need to set the object material properties.</p>
					<div align="left">
						<p align="left">
GLfloat earth_mat_ambient[] = { 0.0f, 0.0f, 1.0f, 1.0f };&nbsp;&nbsp;&nbsp; <br>
GLfloat earth_mat_diffuse[] = { 0.0f, 0.0f, 0.5f, 1.0f };&nbsp; <br>
GLfloat earth_mat_specular[] = { 1.0f, 0.0f, 0.0f, 1.0f };&nbsp;&nbsp; <br>
GLfloat earth_mat_emission[] = { 0.0f, 0.0f, 0.0f, 1.0f };&nbsp;&nbsp;&nbsp;&nbsp;
<br>
GLfloat earth_mat_shininess = 30.0f;<br>
glMaterialfv(GL_FRONT, GL_AMBIENT, earth_mat_ambient);<br>
glMaterialfv(GL_FRONT, GL_DIFFUSE, earth_mat_diffuse);<br>
glMaterialfv(GL_FRONT, GL_SPECULAR, earth_mat_specular);<br>
glMaterialfv(GL_FRONT, GL_EMISSION, earth_mat_emission);<br>
glMaterialf(GL_FRONT, GL_SHININESS, earth_mat_shininess);<br>
						</p></div>
						<br>
						After defining the material properties of the object, 
						you can define drawObject() function that you write to 
						draw the object with lighting enabled.
The drawObject() function need to specify normal for each vertex or face. For 
						example, to define a vertex normal, you can do it like:<div align="left">
							<p align="left">
glNormal3f(nx, ny, nz);<br>
glVertex3f(x, y, z);<br>
<br>
							</p></div>
And you can ask OpenGL to re-normalize the normal automatically:
							<div align="left">
								<p align="left">
glEnable(GL_NORMALIZE);<br>
								</p></div>
<p>Note that normalization of normal is very important! Of course, you can calculate 
the normal to define (nx, ny, nz) based on face normal caluclation:</p>
								<div align="left">
									<p align="left">
triangle(v1,v2,v3);<br>
edge1 = v2-v1;<br>
edge2 = v3-v1;<br>
triangle.normal = cross(edge1, edge2).normalize();<br>
<br>
void normalize(float v[3]) <br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GLfloat d = sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]+e);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v[0] /= d; v[1] /= d; v[2] /= d;<br>
}<br>
									</p></div>
<p>Here, e is a small value which can be set 1e-6 to omit zero case.</p>
									<p align="center">
<img src="./Assignment 1_files/light1.png" class="clean" alt="phong components" width="400" align="left">
									</p>
<p>　</p>
									<p>　</p>
									<p>　</p>
									<p>　</p>
									</font><p><font face="Trebuchet MS" size="3"><br>
									Figure 2: object rendering without and with 
									lighting enabled.<br>
									<br>
									<b>Phong shading with OpenGL 
shaders. </b>The previous program can render object with 3D appearance, but its 
									specular light cannot be well preserved, 
									especially when the object mesh is 
									relatively coarse. In the lecture, we 
									introduced that Phong shading can overcome 
									such an issue, but such a mechanism can only 
									be achieved using OpenGL shaders, which 
									interpolate normals at each pixel and 
									calculate lighting at each pixel. To know 
									how it can work, let's first briefly look at 
									the shader in OpenGL. In OpenGLpipeline, each stage has a set of inputs and outputs, 
which are passed from prior stages and to subsequent stages (whether programmable 
									shaders are used or not). 
Below you'll find an abstract representation of all the stages of the graphics pipeline. Note that the blue sections represent sections where we can 
									insert our own shaders.</font></p>
									<p align="left">
									<font face="Trebuchet MS" size="3">&nbsp;<img src="./Assignment 1_files/pipeline.png" class="clean" alt="The OpenGL graphics pipeline with shader stages" width="400"></font></p>
									<p align="left">
									<font face="Trebuchet MS" size="3">Figure 3: 
									OpenGL pipeline with programmable shaders</font>.</p>
									<font face="Trebuchet MS" size="3">

<p align="left">
  The first thing we need to do is to write the vertex shader in OpenGL shading language GLSL (which 
	is similar as C) and  then compile this shader so we can use it in our application. 
  Below you'll find the source code of a very basic vertex shader and fragment shader in GLSL:
</p>
									<div align="left">
										<p align="left">
#version 330 core<br>
layout (location = 0) in vec3 aPos;<br>
void main()<br>
{<br>
&nbsp;&nbsp;&nbsp; gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);<br>
}<br>
										</p></div>
										<div align="left">
											<p align="left">
#version 330 core<br>
out vec4 FragColor;<br>
void main()<br>
{<br>
&nbsp;&nbsp;&nbsp; FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);<br>
}<br>
<br>
											</p></div>
											To insert the shaders into the OpenGL pipeline, you need 
											to use related OpenGL functions to compile, link and use it. This assignment will provide a shader class which you use it's function to do these job. 
											The course webpage also provides a 
											book on
											<a href="http://sist.shanghaitech.edu.cn/faculty/liuxp/course/s!AvhyQ31jLRnowxhOB64TPHRdbjic3gh2cg1/materials/GLSL4.5.pdf">
											OpenGL shading language</a> that you 
											can refer.
<p>To realize the Phong shading, you will need to interpolate the normals 
automatically using pixel shader, and then perform the Phong lighting 
calculation by yourself (with the equations in course slides). Think about how 
this can be achieved.</p>
<p>Check more for OpenGL 
											lighting at
											<a href="http://www.opengl-tutorial.org/beginners-tutorials/tutorial-8-basic-shading/">
											site1</a> &amp;
											<a href="https://learnopengl.com/Lighting/Basic-Lighting">
											site2</a>.<br>




											</p>




<p align="left"><br>
<b><font face="Trebuchet MS" size="4">Step 5: Transforming objects and 
manipulating camera</font></b></p>
											<p> <b>Object transformations.</b> 
											In many cases, you will want to 
											transform your object to translate 
											or rotate in some consecutive 
											sequence, and sometimes you want to 
											scale the object.<b> </b>To do this, you need to know the transform matrix: translation matrix, rotation matrix, scaling matrix, 
											which we have introduced in the 
											lecture.
In OpenGL, when a vector is under a transformation, you'll need to multiply the 
											corresponding matrix by some OpenGL 
											API functions. </p>
											<p> If you want to control the camera or 
											move/rotate your object, you need to change the 
											model-view matrix.
And the framework code may like this: </p>
											<div align="left">
												<p align="left">
while (!glfwWindowShouldClose(window))<br>
{		<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glClearColor(0.2f, 0.3f, 0.3f, 1.0f);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //DrawObjectWithTransform();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glfwSwapBuffers(window);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glfwPollEvents();<br>
}<br>
												</p></div>
												<p>Here is a sample code which can rotate the triangle around the y aixs 
												with respect to time. </p>
												<div align="left">
													<p align="left">
void DrawObjectWithTransform()<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glPushMatrix();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rotate = glfwGetTime()*30;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glRotatef(rotate, 0.0, 1.0, 0.0);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //draw triangle<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glPopMatrix();<br>
}</p></div>
													<p>Of course, you can translate your object 
													by using the function glTranslate(). </p>
													<p>Check more for OpenGL 
													transformation at
													<a href="http://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices/">
													site1</a> &amp;
													<a href="https://learnopengl.com/Getting-started/Transformations">
													site2</a>.</p>


													<p><b><br>
													Navigate in virtual world.
													</b>To navigate in your 
													virtual scene, you need to 
													change your camera from time 
													to time. Assume that you have known three vector:  up vector 
													<b>U</b>, view direction vector 
													<b>D</b>. We only have to specify a camera position, a target position and a vector that represents 
the up vector in world space (the up vector we used for calculating the right vector), 
													and the OpenGL will help you 
													construct the view matrix by 
													gluLookAt(...). If we want 
													to achieve pitch and yaw of 
													the camera, we only need to 
													change the target position 
													that the camera looks at in 
													gluLookAt(...). If we want 
													to roll the camera, we will 
													need to change the up vector 
													in gluLookAt(...). To move 
													the camera, we change the 
													camera position in gluLookAt(...).</p>


<h4>Walk around using keyboard input. <span style="font-weight: 400">Swinging the camera around a scene is fun, but 
there's more fun to do all the movements by ourselves! First we need to set up a camera system, 
so it is useful to define some camera variables at the top of our program: First we set the camera position to the previously defined cameraPos. The direction is the current position 
added by the direction vector 
we just defined. This ensures that whenever we move, the camera keeps looking at the target direction 
before the camera. </span></h4>

<h4>Look around using mouse input. <span style="font-weight: 400">The yaw and pitch values are obtained from mouse (or controller/joystick) movement where horizontal mouse-movement 
affects the yaw and vertical mouse-movement affects the pitch. When handling 
mouse input for a camera, there are several steps 
we have to take before eventually retrieving the direction vector: 1. Calculate the mouse's offset 
as compared to the last frame;

2. Add the map the offset values to the camera's yaw and pitch values and add to 
them;

3 Add some constraints to the maximum/minimum yaw/pitch values;

4. Calculate the direction vector.</span></h4>
													<p>Check more
													<a href="https://learnopengl.com/Getting-started/Camera">
													here</a> for OpenGL camera 
													transformation.</p>




<hr style="background-color: #666666" color="#666666" size="1">
<p align="left">Skeleton program</p>
<p align="left">We have prepared a 
skeleton program for you on both <a href="http://sist.shanghaitech.edu.cn/faculty/liuxp/course/s!AvhyQ31jLRnowxhOB64TPHRdbjic3gh2cg1/assignments/assignment1/code/win.rar">Windows</a> and
<a href="http://sist.shanghaitech.edu.cn/faculty/liuxp/course/s!AvhyQ31jLRnowxhOB64TPHRdbjic3gh2cg1/assignments/assignment1/code/linux.rar">Linux</a>, based on which you can build your first graphics 
program. Of course, to successfully accomplish the assignment, you will need to read the 
related materials from the links that we give to you. Note that some items must 
be installed before you really compile your program on Linux. See the related 
dependencies in makefile for Linux. If you have any questions regarding 
configuration, you can resort to help from TAs.</p>
<hr style="background-color: #666666" color="#666666" size="1">
<p align="left">Technical report</p>
<p align="left">For technical report, we require you 
to do it with <a href="https://www.latex-project.org/">LaTex</a>, and you can 
use <a href="https://www.texstudio.org/">TeXstudio</a> to facilitate your 
editing. The latex template for your technical report can be downloaded <u>
<a href="http://sist.shanghaitech.edu.cn/faculty/liuxp/course/s!AvhyQ31jLRnowxhOB64TPHRdbjic3gh2cg1/assignments/assignment1/latex_temp/latex_temp.rar">here</a></u>.</p>
<hr style="background-color: #666666" color="#666666" size="1">
<p align="right">Copyright 2018 
ShanghaiTech University</p>



													</font>

</body></html>